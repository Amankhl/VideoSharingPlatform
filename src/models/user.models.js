import mongoose, {Schema} from "mongoose";
import jwt from "jsonwebtoken";   // jwt is a bearer token, meaning whoever bears/has this token can access the database like a key
import bcrypt from "bcrypt";

 
const userSchema = new Schema(
    {
        username:{
            type:String,
            required:true,
            unique:true,
            lowercase:true,
            trim:true,
            index:true // this helps to allow for searching by username by optimizing the database
        },
        email:{
            type:String,
            required:true,
            unique:true,
            lowercase:true,
            trim:true
        },
        fullName:{
            type:String,
            required:true,
            trim:true,
            index:true 
        },
        avatar:{
            type:String,   // cloudnary url
            required:true
        },
        coverImage:{
            type:String,   // cloudnary url
        },
        watchHistory:[
            {
                type: Schema.Types.ObjectId,
                ref: "Video"
            }
        ],
        password:{
            type:String,
            required:[true,"Password is required"]
        },
        refreshToken:{
            type:String
        }
    },
    {timestamps:true}
)


userSchema.pre("save", async function(next){  // event is 'save' -> middleware that runs on some event in this case 'save' -> before data is saved. The Next is important in middlewares to pass control/flag to the next middleware.
    if (!this.isModified("password")) return next();   // if condition checks if the password is modified or created, if not, it returns next. and if yes it continues hashing the password. this check is important because whenever a user changes their profile and clicks on save button, it will hash the password everytime.
    this.password = await bcrypt.hash(this.password, 10); // which is to be encrypted and how many rounds
    // We cannot use aero function as an argument here because aero functions do not have context or 'this' reference, that's why we have used a normal function.
    next();
})

userSchema.methods.isPasswordCorrect = async function(password){
    return await bcrypt.compare(password, this.password); // the original password (string) a user has entered and the password that is stored in the database (encrypted)
}
// explained below
userSchema.methods.generateAccessToken = function(){
    return jwt.sign( //sign method is used to create a bearer token
        {
        _id: this._id,
        email: this.email,
        username: this.username,
        fullName: this.fullName
        },                             // Payload: The payload of the JWT (the first argument of jwt.sign) contains the data you want to include in the token. Here, _id, email, username, and fullName are typically user-specific data that can be used to identify and verify the user later.
        process.env.ACCESS_TOKEN_SECRET,   // Secret: is the secret key used to sign the token. It's used to verify that the token was indeed generated by your application.
        {
            expiresIn: process.env.ACCESS_TOKEN_EXPIRY   //indicating how long the token should remain valid.
        }
    )
}
userSchema.methods.generateRefreshToken = function (){
    return jwt.sign( //sign method is used to create a bearer token
        {
            _id: this._id
        },
        process.env.REFRESH_TOKEN_SECRET,
        {
            expiresIn: process.env.REFRESH_TOKEN_EXPIRY
        }
    )
}


export const User = mongoose.model("User",userSchema); // it gives you a model (User) with the schema (userSchema). The model is imported and used to interact with the database





/*

Pre middleware functions are executed one after another, when each mkddleware calles next.
They are used to execute some code just before the next middleware is called or data is saved.
In our case, we want to use Pre middleware just before saving some data, we want this to encrypt password a user has entered before it is saved.


With "salt round" they actually mean the cost factor. The cost factor controls how much time is needed to calculate a single BCrypt hash.
A cost factor of 10 means that the calculation is done 2^10 times which is about 1000 times.
The more rounds of calculation you need to get the final hash, the more cpu/gpu time is necessary. 
This is no problem for calculating a single hash for a login, but it is a huge problem when you brute-force millions of password combinations.




Why Compare Passwords?
User Authentication:

- When a user attempts to log in, they provide their plaintext password along with their username or email.
To verify the user's identity, the application needs to check if the provided password matches the one stored in the database.
Security:

- Passwords are stored in the database in a hashed form (not as plaintext) for security reasons. Hashing is a one-way function that converts the plaintext password into a fixed-length string.
When a user logs in, the application cannot compare the provided password directly with the hashed password in the database because they are not in the same form.
Instead, the application hashes the provided password and then compares the plaintext password provided by the user with the hashed password stored in the database using a function like bcrypt.compare.
returns true if the provided password matches the hashed password in the database, and false otherwise.


# `.methods` is a property (object) of Mongoose schemas that allows you to define instance methods for your Mongoose models in this object(.methods) as its property. These instance methods can be called on instances of the model.
The code defines an instance method named isPasswordCorrect on the userSchema. This method can then be called on any instance (individual object created from the User model) to check if the provided password is correct.

# Example code:
const user = new User({
    username: 'john_doe',
    email: 'john@example.com',
    fullName: 'John Doe',
    avatar: 'http://example.com/avatar.jpg',
    password: 'hashedpassword'
});

await user.save();
const isPasswordValid = await user.isPasswordCorrect('enteredPassword');       // isPasswordCorrect is used on the user (an instance of User model) 
if (isPasswordValid) {
    console.log('Password is correct');
} else {
    console.log('Password is incorrect');
}



in the same way we have made generateAccessToken, generateRefreshToken in the User model 



# Usage of the Access Token
Once the generateAccessToken method is called and a token is generated typically created when a user successfully authenticates with your application:


1) User Authentication: A user submits their credentials (such as username/email and password) to your application's authentication endpoint.

2) Authentication Verification: Your server verifies the credentials against the stored user data (e.g., in a database). isPasswordCorrect is used to check if the provided password is correct.

3) Token Generation: If the credentials are valid, your server generates an access token using the generateAccessToken method.
  This token is a JWT containing information about the user (such as _id, email, username, fullName).

4) Sending to Client: The generated token is then sent back to the client (e.g., frontend application) in the HTTP response body or headers after successful authentication.
  This can be done as a JSON response body, an HTTP header (commonly Authorization header with value Bearer <token>), or in some cases,
  as a cookie (typically an HTTP-only cookie for security reasons).

5) Client Storage: The client (e.g., a web browser for a web application) then stores this token securely.
  It's commonly stored in localStorage, sessionStorage, or in an HTTP-only cookie depending on security and application requirements.

6) Sending with Requests/Token Usage: For subsequent requests requiring authentication, the client includes this token in the Authorization header (commonly `Authorization` header with value `Bearer <token>`),
  or in some cases, in the request body.

7) Server Verification: When the server receives a request with the token, it verifies the tokenâ€™s authenticity and validity. This involves decoding the token using
  the ACCESS_TOKEN_SECRET (the same secret used to sign the token during generation). If the token is valid and not expired, the server processes the request and provides the appropriate response.

8) Request Processing: If the token is valid and not expired, the server processes the request and provides the appropriate response.
  The token payload (e.g., _id, email) can be used by the server to identify the authenticated user and authorize the requested actions.





*/